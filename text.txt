Уже реализованы

Классы для работы:

Geo - Базовый класс для работы с географическими данными
Его задача определить текущий язык и преобразовать его в стандартное название.
Пример: у нас язык английский - это 'us', а браузер не понимает такое название, поэтому через Geo.lang.value уже вернёт стандартный 'en'.

GeoIntl - Класс для работы с форматированием даты, чисел, валюты. Все это будет учитывать, какой язык открыт на сайте и какая страна.
Пример:
Geo.set('ru')
new GeoIntl().number('123456.789').value //  123 456,789
new GeoIntl().currency('123456.789', 'RUB').value //  123 456,79 ₽
new GeoIntl().unit('123', 'kilogram').value //  123 кг
new GeoIntl().date('1987-09-21').value //  21 сент. 1987 г.
new GeoIntl().relative('2023-07-21 20:30:10').value //  3 часа назад
new GeoIntl().relative('2023-06-15 20:30:10').value //  в прошлом месяце
new GeoIntl().relative('2013-06-15').value //  10 лет назад

Geo.set('ko')
new GeoIntl().number('123456.789').value //  123,456.789
new GeoIntl().currency('123456.789', 'RUB').value //  RUB 123,456.79
new GeoIntl().unit('123', 'kilogram').value //  123kg
new GeoIntl().date('1987-09-21').value //  1987년 9월 21일
new GeoIntl().relative('2023-07-21 20:30:10').value //  3시간 전
new GeoIntl().relative('2023-06-15 20:30:10').value //  지난달
new GeoIntl().relative('2013-06-15').value //  10년 전

StorageItem, SessionItem, Hash, Cookie - Классы для работы с сохранением данных
Пример:
const value = ref()
const storage = new StorageItem('test', value)

value.value = 'hello'
storage.get().value // 'hello' и в localStorage значение будет равно 'hello'


Кратко:

1) Есть глобальные файлы с токенами. В них описаны цвета, размеры, шрифты, фоны и т.д.
А также описания, какие токены используются в компоненте и где (пример color: "{ref.palette.black}").

2) Есть файлы с настройками для токенов. Тут разработчик описывает, где что лежит,
что и как преобразовывать, чтобы система правильно понимала токены и правильно сгенерировала код.
Пример:
"background-color": {
  "_rename": "palette-background"
}

Тут говорим, что свойство "background-color" надо заменить на "palette-background".

Файл с настройками есть 1 глобальный и у каждого компонента будет свой.

3) Сам компонент будет разделено на 2 части: Конструктор (класс) и сам файл vue.

3.1) Конструктор - это класс, где находится базовый функционал. Его задача - это реализация работы компонента.
А также в нём описываются какие параметры есть, события, слоты.

3.2) Также у конструктора есть файл style.scss, где мы верстаем недостающие свойства, которых нет
в токена. Но обычно это относится к общей структуре, и не относится к дизайну.
Пример:
display: flex;
position: relative;
cursor: pointer;

3.3) Сам компонент vue - это по сути связующее звено между конструктором и токенами. В нём по сути
только подключение идёт всех файлов и доработки чего-либо, которое надо только в конкретной версии компонента.

Пример для кнопки
В Конструкторе мы описываем, как пользоваться иконкой, загрузчиком. В каких случаях кнопка активна.
События нажатия (emit). Переменные, которые не связаны с дизайном (label, icon)
В vue файле подключаем Конструктор и заполняем настройками для токенов

"contained": {
    "_category": "appearance",
    "_default": true
},
"outlined": {
    "_category": "appearance"
},
"text": {
    "_category": "appearance"
},
Говорим, что contained, outlined, text - это парамер одного категория appearance, и их не надо включить вместе,
а contained - это значение по умолчанию ("_default": true)

По сути идет разделение на 3 основы, токены, конструктор и файл vue.
Разделение функционала в один класс для возможности пере-использования и меньшего повторения кода.
То есть у нас появилась новая кнопка, мы просто создаем новый vue файл, подключаем уже написанный старый конструктор.
И пока разрабатывается новый дизайн, не надо будет поддерживать сразу 2 версии, как код функционала 1 на оба.


По токенам + настройкам для токенов + style.scss генерируется класс и свойства для стилей.
По токенам + настройкам для токенов генерируются уже props и правила подключения классов.
То есть структурировать класс, и как, и когда его подключать уже все автоматически генерируется.

Пример:
<md3-chip
  // прописывает в файле конструктор
  tag="button"
  label="Dragged"
  icon="face"
  progress
  @click="dragged = !dragged" // прописывает в файле конструктор
  // внешности, генерируются из токена
  assist
  elevated
  filter
  selected
  dragged
  // указывает цвет, источник цветов из токена, а настраивается парой строк кода
  palette="error"
/>



Подключения
Наш проект будет находиться в своем git. Там будут только компоненты и все функциональности.
Собранный код (build готовый) мы разместим на нашем сайте (в папке, например, DesignCore).
У кода ядра не будет никаких глобальных стилей, которые меняют что-то глобально (цвета, фон и т.д.), чтобы не повлияло на дизайн сайта.

Подключения этого ядра будет черед php класс
Пример: DesignCore->init()
Этот метод сработает только 1 раз, то есть если при выполнении кода было вызвано несколько
раз DesignCore->init(), сработает только первый раз.
Подключать его я пока планирую вручную, когда будет нужно. То есть если в разработке
понадобится, то подключаем и работаем. Я не хочу его пока что подключать глобально, так как
у нас много страниц, и не знаю, будут ли проблемы какие-то на какой-то странице или нет.

Использования
Для использования, будет 3 способ

1) Самый просто черед тег и атрибуты. Для этого способа надо просто вызвать DesignCore->init().
Пример
<span
  data-md2="button"
  data-inscription="button (slot)"
  data-icon="home"
  // Для события регистрируем функцию глобально и ставим ее имя,
  // поэтому желательно, чтобы оно было длинным и уникальным.
  data-on-click="isClick"
>
  // Слот можно через атрибут data-slot=“название”, или без, если он один. Но нельзя совмещать оба варианта!
  <b>slot</b>
  // или
  <span data-slot="default">
    <b>slot</b>
  </span>
</span>

Ставить этот код можно везде и когда угодно. То есть можно черед ajax.
Есть техническая демка здесь https://ru.dev2.coralclub.app/test/dist/

2) Второй способ это для большой компонент:
Это будет 1 файл package.json
Пример содержимого этого файла:
{
  "name": "@coral-club/DesignCore",
  "version": "0.0.1-dev-2",
  "scripts": {
    "init": "coral/commands/init.js",
    "initFull": "coral/commands/init.js -f"
  },
  "devDependencies": {
    "coral": "git+https://Duong:glpat-sNVS4HxmGphdrSYVu7LN@git.coral.club/Duong/DesignCore.git"
  }
}

2.1) Скопируем этот файл в чистую папку.
2.2) Вызываем npm install.
2.3) Вызываем команду init (сборка для нашего сайта) или initFull (сборка для нового сайта).
Он сгенерирует все нужные файлы для работы с "DesignCore" и "vue cli".
Разница init и initFull будет в сборке, init будет собирать бес ядро vue и DesignCore.
2.4) Настраиваем файл .env (там, наверное, будет просто параметр, где ваш код будет находиться (url на сайте), может, что-нибудь еще придумаю).
Кодим, как обычно (запускаем serve как обычно).
2.5) Собираем и выкладываем на нашем сайте в папку DesignCore/<название проекта>/
Потом подключаем через наш php класс DesignCore->initComponent('<название проекта>')
Если надо использовать несколько раз, можно сначала
DesignCore->includeComponent('<название проекта>')
потом, где используем, уже DesignCore->initComponent('<название проекта>')

(ВНИМАНИЕ! Я еще не начал делать эту часть)

3) И последний способ - это подключение к рабочему vue проекту, но это не желательно. Лучше сделать второй варианта и перенести код туда.
Поскольку проекты с vue 2 не будут иметь возможности так реализовывать, а у нас много где используется vue 2.
Перенос не будет проблемой, так как vue 3 прекрасно работает с кодом из vue 2.

3.1) Добавляем в package.json наш пакет.
"coral": "git+https://Duong:glpat-sNVS4HxmGphdrSYVu7LN@git.coral.club/Duong/DesignCore.git"
3.2) Добавляем в "main.ts/main.js" include и строка ".use(DesignCore)"
3.3) Добавляем в "main.scss" import и строка "include initDesignCore";
3.4) В vue.config.js оборачиваем в DesignCoreConfig({...тут ваши старые настройки})
3.5) Работаем

Но я скорее всего сделаю команду, которая сгенерирует эти коды.

(ВНИМАНИЕ! Я еще не начал делать эту часть)


Плагин для figma
Если компания оплатит figma, это будет бомба.
Я напишу плагин, который сгенерирует готовый код для vue/html/ios/android при наведении на компонент.
И в этом направлении еще можно много чего придумать. Но это из разряда фантазии, не буду описывать, так как уверен, что руки не дойдут. :)
Это будет выглядеть как на скрине, справа будет наш готовый код.

Vue
<md3-chip
  tag="button"
  filter
  icon="face"
  label="Dragged"
  dragged
/>

HTML
<span
  data-md2="chip"
  data-tag="button"
  data-filter
  data-icon="face"
  data-label="Dragged"
  data-dragged="dragged"
/>
